<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../marked-element/marked-element.html">
<link rel="import" href="quoted-printable.html">

<!--
`now-richtext`
Element to handle Notes RichText delivered via DDS

@element now-richtext
@demo demo/index.html
-->

<dom-module id="now-richtext">
	<template>
		<style>
			:host {
				display: block;
				box-sizing: border-box;
			}
			#markdownHtml {
				@apply --now-richtext-markdown-html
			}
		</style>
		<marked-element id="marked" markdown="{{htmlContent}}">
			<div id="markdownHtml" slot="markdown-html"></div>
		</marked-element>
	</template>
	<script>
class NowRichtext extends Polymer.Element {
	static get is() {
		return 'now-richtext';
	}
	get is() {
		return NowRichtext.is;
	}
	static get properties() {
		return {
			/**
			 * The property to add to the marked-element. This is the decoded rich text
			 * @type {String}
			 */
			 htmlContent: String,
			/**
			 * The multipart MIME object for the rich text field
			 * @type {Object}
			 */
			richTextObj: {
				type: Object,
				observer: '_onRichText'
			},
			/**
			 * True to remove html, head and body tags. Will also remove all attributes
			 * from font tags
			 * @type {Boolean}
			 */
			cleanHtml: {
				type: Boolean,
				value: false
			}
		};
	}
	constructor() {
		super();
	}
	/**
	 * Observer fired when the richTextObj changes. Decode the rich text html content
	 * @param  {Object} newVal new value
	 * @param  {Object} oldVal Old value
	 */
	_onRichText(newVal, oldVal) {
		if (newVal) {
			const textObj = newVal.content;
			for (let i = 0; i < textObj.length; i++) {
				const mimeObj = textObj[i];
				if (mimeObj.contentType.indexOf('text/html') > -1) {
					let html = mimeObj.data;
					if (mimeObj.contentTransferEncoding === 'base64') {
						html = atob(mimeObj.data);
					}else if (mimeObj.contentTransferEncoding === 'quoted-printable') {
						html = quotedPrintable.decode(mimeObj.data);
					}
					html = this.cleanHtml ? this._cleanupHtml(html) : html;
					this.set('htmlContent', html);
				}
			}
			// Gotta wait for the DOM to be built
			setTimeout(function() {
				this._updateImages(textObj);
			}.bind(this), 200);
		}
	}
	/**
	 * Ensure images are displayed. Find all images and update the img tag src attribute
	 * or replace the text node for an attachment with an img
	 * @param  {Array} mimeObjContent The array of mime parts
	 */
	_updateImages(mimeObjContent) {
		for (let j = 0; j < mimeObjContent.length; j++) {
			const mimeObj = mimeObjContent[j];
			if (mimeObj.contentType.startsWith('image/')) {
				const contentDispo = mimeObj.contentDisposition;
				const isInline = contentDispo.startsWith('inline');
				const markedContent = this.$.markdownHtml;
				let elem = null;
				let srcAttrStr = null;
				if (isInline) {
					// console.log(this.is, '_updateImages, inline', contentDispo);
					const imageBase64 = mimeObj.data;
					const imgElemName = 'cid:' + mimeObj.contentID.substring(1, mimeObj.contentID.length - 1);
					const contentType = mimeObj.contentType.split(';')[0];
					const elems = markedContent.querySelectorAll('[src="' + imgElemName + '"]');
					if (elems && elems.length > 1) {
						for (let l = 0; l < elems.length; l++) {
							const el = elems[l];
							if (el) {
								srcAttrStr = 'data:' + contentType + ';base64,' + imageBase64;
								el.setAttribute('src', srcAttrStr);
							}
						}
					}else if (elems && elems.length === 1) {
						// elem = markedContent.querySelector('[src="' + imgElemName + '"]');
						elem = elems[0];
						if (elem) {
							srcAttrStr = 'data:' + contentType + ';base64,' + imageBase64;
							elem.setAttribute('src', srcAttrStr);
						}
					}
				}else { // Gotta create an img tag for attachments
					// console.log(this.is, '_updateImages, NOT inline', contentDispo);
					const elemArr = markedContent.querySelectorAll('i');
					for (let k = 0; k < elemArr.length; k++) {
						elem = elemArr[k];
						const dispoArr = mimeObj.contentDisposition.split(';');
						const fileNamePart = dispoArr[1].substring(dispoArr[1].indexOf('="') + 2, dispoArr[1].lastIndexOf('"'));
						if (elem.innerHTML.indexOf(fileNamePart) > -1) {
							const parent = elem.parentNode;
							const img = document.createElement('img');
							const contentTypeArr = mimeObj.contentType.split(';');
							srcAttrStr = 'data:' + contentTypeArr[0] + ';base64,' + mimeObj.data;
							img.setAttribute('src', srcAttrStr);
							parent.replaceChild(img, elem);
						}
					}
				}
			}
		}
	}
	/**
	 * Remove any html, head and body tags. Remove all attributes
	 * from font tags
	 * @param {string} html
	 * @returns {string}
	 */
	_cleanupHtml(html) {
		if (html) {
			const htmlElem = document.createElement('html');
			htmlElem.innerHTML = html;
			const head = htmlElem.querySelector('head');
			head.remove();
			const body = htmlElem.querySelector('body');
			const fonts = body.querySelectorAll('font');
			for (let i = 0; i < fonts.length; i++) {
				const font = fonts[i];
				font.removeAttribute('face');
				font.removeAttribute('color');
				font.removeAttribute('size');
			}
			return body.innerHTML;

			// const removeText = ['<html>','</html>','<body>','</body>','<head>','</head>'];
			// for (let j = 0; j < removeText.length; j++) {
			// 	html = html.replace(removeText[j],'');
			// }
		}
		return null;
	}
}
customElements.define(NowRichtext.is, NowRichtext);
	</script>
</dom-module>
