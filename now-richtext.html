<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../marked-element/marked-element.html">
<link rel="import" href="quoted-printable.html">

<!--
`now-richtext`
Element to handle Notes RichText delivered via DDS

@element now-richtext
@demo demo/index.html
-->

<dom-module id="now-richtext">
	<template>
		<style>
			:host {
				display: block;
				box-sizing: border-box;
			}
			#markdownHtml {
				@apply --now-richtext-markdown-html
			}
		</style>
		<marked-element id="marked" markdown="{{htmlContent}}">
			<div id="markdownHtml" slot="markdown-html"></div>
		</marked-element>
	</template>
	<script>
class NowRichtext extends Polymer.Element {
	static get is() {
		return 'now-richtext';
	}
	get is() {
		return NowRichtext.is;
	}
	static get properties() {
		return {
			/**
			 * The property to add to the marked-element. This is the decoded rich text
			 * @type {String}
			 */
			 htmlContent: String,
			/**
			 * The multipart MIME object for the rich text field
			 * @type {Object}
			 */
			richTextObj: {
				type: Object,
				observer: '_onRichText'
			},
			/**
			 * True to remove html, head and body tags. Will also remove all attributes
			 * from font tags
			 * @type {Boolean}
			 */
			cleanHtml: {
				type: Boolean,
				value: false
			}
		};
	}
	constructor() {
		super();
	}
	/**
	 * Observer fired when the richTextObj changes. Decode the rich text html content
	 * @param  {Object} newVal new value
	 * @param  {Object} oldVal Old value
	 */
	_onRichText(newVal, oldVal) {
		if (newVal) {
			const textObj = newVal.content;
			for (let i = 0; i < textObj.length; i++) {
				const mimeObj = textObj[i];
				if (mimeObj.contentType.indexOf('text/html') > -1) {
					let html = mimeObj.data;
					if (mimeObj.contentTransferEncoding === 'base64') {
						html = atob(mimeObj.data);
					}else if (mimeObj.contentTransferEncoding === 'quoted-printable') {
						html = quotedPrintable.decode(mimeObj.data);
					}
					html = this.cleanHtml ? this._cleanupHtml(html) : html;
					this.set('htmlContent', html);
				}
			}
			// Gotta wait for the DOM to be built
			setTimeout(function() {
				this._updateImages(textObj);
			}.bind(this), 200);
		}
	}
	/**
	 * Ensure images are displayed. Find all images and update the img tag src attribute
	 * or replace the text node for an attachment with an img
	 * @param  {Array} mimeObjContent The array of mime parts
	 */
	_updateImages(mimeObjContent) {
		for (let j = 0; j < mimeObjContent.length; j++) {
			const mimeObj = mimeObjContent[j];
			if (mimeObj.contentType.startsWith('image/')) {
				const contentDispo = mimeObj.contentDisposition;
				const isInline = contentDispo.startsWith('inline');
				const markedContent = this.$.markdownHtml;
				let elem = null;
				let srcAttrStr = null;
				if (isInline) {
					// console.log(this.is, '_updateImages, inline', contentDispo);
					const imageBase64 = mimeObj.data;
					const imgElemName = 'cid:' + mimeObj.contentID.substring(1, mimeObj.contentID.length - 1);
					const contentType = mimeObj.contentType.split(';')[0];
					const elems = markedContent.querySelectorAll('[src="' + imgElemName + '"]');
					if (elems && elems.length > 1) {
						for (let l = 0; l < elems.length; l++) {
							const el = elems[l];
							if (el) {
								srcAttrStr = 'data:' + contentType + ';base64,' + imageBase64;
								el.setAttribute('src', srcAttrStr);
							}
						}
					}else if (elems && elems.length === 1) {
						// elem = markedContent.querySelector('[src="' + imgElemName + '"]');
						elem = elems[0];
						if (elem) {
							srcAttrStr = 'data:' + contentType + ';base64,' + imageBase64;
							elem.setAttribute('src', srcAttrStr);
						}
					}
				}else { // Gotta create an img tag for attachments
					// console.log(this.is, '_updateImages, NOT inline', contentDispo);
					const elemArr = markedContent.querySelectorAll('i');
					for (let k = 0; k < elemArr.length; k++) {
						elem = elemArr[k];
						const dispoArr = mimeObj.contentDisposition.split(';');
						const fileNamePart = dispoArr[1].substring(dispoArr[1].indexOf('="') + 2, dispoArr[1].lastIndexOf('"'));
						if (elem.innerHTML.indexOf(fileNamePart) > -1) {
							const parent = elem.parentNode;
							const img = document.createElement('img');
							const contentTypeArr = mimeObj.contentType.split(';');
							srcAttrStr = 'data:' + contentTypeArr[0] + ';base64,' + mimeObj.data;
							img.setAttribute('src', srcAttrStr);
							parent.replaceChild(img, elem);
						}
					}
				}
			}
		}
	}
	/**
	 * Remove any html, head and body tags. Remove all attributes
	 * from font tags
	 * @param {string} html
	 * @returns {string}
	 */
	_cleanupHtml(html) {
		if (html) {
			const htmlElem = document.createElement('html');
			htmlElem.innerHTML = html;
			const head = htmlElem.querySelector('head');
			head.remove();
			const body = htmlElem.querySelector('body');
			const fonts = body.querySelectorAll('font');
			for (let i = 0; i < fonts.length; i++) {
				const font = fonts[i];
				font.removeAttribute('face');
				font.removeAttribute('color');
				font.removeAttribute('size');
			}
			return body.innerHTML;

			// const removeText = ['<html>','</html>','<body>','</body>','<head>','</head>'];
			// for (let j = 0; j < removeText.length; j++) {
			// 	html = html.replace(removeText[j],'');
			// }
		}
		return null;
	}
	/**
	 * Get the text nodes that display something like
	 * "(See attached file: someFileName.pdf)". This allows
	 * you to wrap that node in a link to the attachment
	 * @returns {any[]}
	 */
	getAttachmentNodes() {
		let attachmentNodes = [];
		if (this.richTextObj && this.richTextObj.content) {
			const mimeObjContent = this.richTextObj.content;
			for (let i = 0; i < mimeObjContent.length; i++) {
				const mimeObj = mimeObjContent[i];
				if (mimeObj.contentDisposition && mimeObj.contentDisposition.startsWith('attachment;')) {
					const dispArr = mimeObj.contentDisposition.split(';');
					const fileNameArr = dispArr[1].split('=');
					let fileName = fileNameArr[1];
					fileName = fileName.replace(/"/g, '');
					const attNode = this._getAttachmentNode(fileName);
					if (attNode) {
						attachmentNodes.push({
							fileName: fileName,
							node: attNode,
							type: mimeObj.contentType
						});
					}
				}
			}
		}
		return attachmentNodes;
	}
	/**
	 * Finds the attachment text which matches
	 * the fileName
	 * @param fileName {string}
	 * @returns {Element}
	 */
	_getAttachmentNode(fileName) {
		let textNode = null;
		if (fileName) {
			const markedHtml = this.$.markdownHtml;
			const iNodes = markedHtml.querySelectorAll('i');
			if (iNodes && iNodes.length > 0) {
				for (let i = 0; i < iNodes.length; i++) {
					const iNode = iNodes[i];
					const iNodeKids = iNode.childNodes;
					for (let j = 0; j < iNodeKids.length; j++) {
						const kid = iNodeKids[j];
						if (kid.nodeType === Node.TEXT_NODE) {
							const iNodeText = kid.textContent;
							if (iNodeText.indexOf('(See attached file:') > -1 && iNodeText.indexOf(fileName) > -1) {
								textNode = iNode;
							}
						}
					}
				}
			}
		}
		return textNode;
	}
	/**
	 * Gets the HTML being displayed in the markdownHtml element
	 * @returns {string}
	 */
	getRichtextInnerHTML() {
		return this.$.markdownHtml.innerHTML;
	}
	/**
	 * Get the "Notes" links contained in the rich text
	 * @returns {any[]}
	 */
	getNotesLinks() {
		const markedHtml = this.$.markdownHtml;
		const links = [];
		const notesLinks = markedHtml.querySelectorAll('a[href^="Notes://"]');
		if (notesLinks && notesLinks.length > 0) {
			for (let i = 0; i < notesLinks.length; i++) {
				const notesLink = notesLinks[i];
				const trimHref = notesLink.href.replace(/Notes:\/\//, '');
				const notesLinkArr = trimHref.split('/');
				links.push({
					linkElem: notesLink,
					hostname: notesLinkArr[0],
					replicaId: notesLinkArr[1],
					unid: notesLinkArr[notesLinkArr.length - 1]
				});
			}
		}
		return links;
	}
}
customElements.define(NowRichtext.is, NowRichtext);
	</script>
</dom-module>
